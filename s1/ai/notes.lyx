#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part
Logic-Based Agents
\end_layout

\begin_layout Section
Something-Something
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\or}{\vee}
\end_inset


\begin_inset FormulaMacro
\newcommand{\and}{\wedge}
\end_inset


\end_layout

\begin_layout Subsection
representation
\end_layout

\begin_layout Standard
a set of symbols
\end_layout

\begin_layout Subsection
models
\end_layout

\begin_layout Standard
parallel universe
\end_layout

\begin_layout Subsection
syntax
\end_layout

\begin_layout Standard
defines the sentence in the language
\end_layout

\begin_layout Subsection
semantics
\end_layout

\begin_layout Standard
defines meaning of sentences, when sentence S is true
\end_layout

\begin_layout Subsection
Sentence
\end_layout

\begin_layout Standard
WHAT'S A SENTENCE?
\end_layout

\begin_layout Subsection
Inference engine
\end_layout

\begin_layout Standard
program to solve the problem
\end_layout

\begin_layout Subsection
knowledge base
\end_layout

\begin_layout Standard
world description (domain.pddl)
\end_layout

\begin_layout Itemize
formal language
\end_layout

\begin_layout Subsubsection
Declarative
\end_layout

\begin_layout Enumerate
define knowledge
\end_layout

\begin_layout Enumerate
query for answers
\end_layout

\begin_layout Subsection
Agents
\end_layout

\begin_layout Standard
an agent is: something that interacts
\end_layout

\begin_layout Subsection
knowledge level
\end_layout

\begin_layout Standard
example: torrent client, browser
\end_layout

\begin_layout Standard
algorithm:
\end_layout

\begin_layout Enumerate
init KB
\end_layout

\begin_layout Enumerate
add_to_kb(perception)
\end_layout

\begin_layout Enumerate
action = query_kb()
\end_layout

\begin_layout Enumerate
make_action(action)
\end_layout

\begin_layout Itemize
implementation level (????)
\end_layout

\begin_layout Subsection
World characterizations
\end_layout

\begin_layout Itemize
Observable: whole world is visible
\end_layout

\begin_layout Itemize
Deterministic: harr harr
\end_layout

\begin_layout Itemize
Episodic: Sequential actions
\end_layout

\begin_layout Itemize
Static: The world doesn't change by iteself
\end_layout

\begin_layout Itemize
Discrete: harr harr
\end_layout

\begin_layout Itemize
Single-Agent: harr harr
\end_layout

\begin_layout Subsection
entailment [deductions] in wumpus
\end_layout

\begin_layout Enumerate
0,0 => nothing
\end_layout

\begin_deeper
\begin_layout Itemize
perception: KB := is_empty(0,0)
\end_layout

\begin_layout Itemize
action: 1 possible situation for the opened squares (empty), pick a direction
\end_layout

\end_deeper
\begin_layout Enumerate
1,0 => breeze
\end_layout

\begin_deeper
\begin_layout Itemize
KB += breeze(0,1)
\end_layout

\begin_layout Itemize
8 possible representation for the opened squares
\end_layout

\begin_layout Itemize
models = filter(eval KB on 8-repr)
\end_layout

\begin_deeper
\begin_layout Itemize
KB allows only 3 possible models
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\alpha_{1}=\text{is\_safe(0,1)}$
\end_inset

 #query
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\alpha_{1}$
\end_inset

 contains all the possible models (3 of them), so is_safe is TRUE 
\begin_inset Formula $KB\models\alpha_{1}$
\end_inset

aka 
\begin_inset Formula $KB\text{ models \alpha}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\alpha_{2}=\text{is\_safe(1,1)}$
\end_inset

 #query
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\alpha_{2}$
\end_inset

 contains only one possible models (1/3), so is_safe is FALSE 
\begin_inset Formula $KB\nvDash\alpha_{2}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Entailment
\end_layout

\begin_layout Standard
\begin_inset Formula $KB\models\alpha$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $(KB\text{ entails }\alpha)\iff(\alpha\text{ is true \forall world where KB) }$
\end_inset


\end_layout

\begin_layout Standard
entailment 
\begin_inset Formula $\models$
\end_inset

 is used to check if a query is true by checking if every statement in the
 query 
\begin_inset Formula $\alpha$
\end_inset

 is ok with 
\begin_inset Formula $KB$
\end_inset


\end_layout

\begin_layout Subsection
Models
\end_layout

\begin_layout Standard
Models are the (parallel) worlds (models of the world) where some sentence
 is true
\end_layout

\begin_layout Itemize
\begin_inset Formula $m_{1}={A,B,C}$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $m_{2}={A,B,D}$
\end_inset


\end_layout

\begin_layout Itemize
in 
\begin_inset Formula $m_{1}$
\end_inset

 A,B,C are true but D=False
\end_layout

\begin_layout Itemize
in 
\begin_inset Formula $m_{2}$
\end_inset

C is false, D is true
\end_layout

\begin_layout Subsubsection
M(x)
\end_layout

\begin_layout Standard
\begin_inset Formula $M(x)\text{ is the set of all the models for x}$
\end_inset


\end_layout

\begin_layout Section
Verify entailment
\end_layout

\begin_layout Subsection
Model checking
\end_layout

\begin_layout Standard
bruteforce
\end_layout

\begin_layout Enumerate
create all the possible models for KB
\end_layout

\begin_layout Enumerate
create all the possible models for 
\begin_inset Formula $\alpha$
\end_inset


\end_layout

\begin_layout Enumerate
result = 
\begin_inset Formula $M(KB)\subseteq M(\alpha)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
if all the models for the world are also models for the query (query is
 always true)
\end_layout

\end_deeper
\begin_layout Subsection
Inference
\end_layout

\begin_layout Standard
\begin_inset Formula $KB\vdash_{i}\alpha$
\end_inset


\end_layout

\begin_layout Itemize
use some inference procedure (i) to check the model
\end_layout

\begin_layout Subsubsection
Soundness
\end_layout

\begin_layout Itemize
\begin_inset Formula $\vdash_{i}\implies\vDash$
\end_inset

, i works
\end_layout

\begin_layout Subsubsection
completeness
\end_layout

\begin_layout Itemize
if i doesn't work then there is no solution
\end_layout

\begin_layout Itemize
i finds a solution if there is one
\end_layout

\begin_layout Part
Propositional logic
\end_layout

\begin_layout Section
Syntax
\end_layout

\begin_layout Subsection
symbols
\end_layout

\begin_layout Itemize
A,B,C,D,
\begin_inset Formula $\dots,$
\end_inset

Etc
\end_layout

\begin_layout Subsection
constants
\end_layout

\begin_layout Itemize
True
\end_layout

\begin_layout Itemize
False
\end_layout

\begin_layout Subsection
operators
\end_layout

\begin_layout Itemize
\begin_inset Formula $\neg,\wedge,\vee,\implies,\iff$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $A\implies B$
\end_inset

 is false only if A is false and B is true
\end_layout

\begin_layout Itemize
\begin_inset Formula $A\iff\text{B equals A\implies B \wedge\ B \implies A}$
\end_inset


\end_layout

\begin_layout Subsubsection
Logical equivalences
\end_layout

\begin_layout Standard
\begin_inset Formula $\alpha\equiv\beta$
\end_inset

 if 
\begin_inset Formula $\alpha\models\beta\wedge\beta\models\alpha$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\wedge$
\end_inset

 is like +
\end_layout

\begin_layout Itemize
\begin_inset Formula $\vee$
\end_inset

 is like *
\end_layout

\begin_layout Itemize
\begin_inset Formula $\alpha\implies\beta\equiv\neg\alpha\implies\neg\beta$
\end_inset

 (contraposition)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\alpha\implies\beta\equiv\neg\alpha\vee\beta$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\neg(\alpha\wedge\beta)\equiv\neg\alpha\vee\neg\beta$
\end_inset

 (same for 
\begin_inset Formula $\vee$
\end_inset

)
\end_layout

\begin_layout Subsubsection
validity
\end_layout

\begin_layout Itemize
\begin_inset Formula $KB\models\alpha$
\end_inset

 IFF 
\begin_inset Formula $KB\implies\alpha$
\end_inset

 is valid (true)
\end_layout

\begin_layout Subsubsection
satisfiability
\end_layout

\begin_layout Itemize
\begin_inset Formula $KB\models\alpha$
\end_inset

 IFF 
\begin_inset Formula $KB\wedge\neg\alpha$
\end_inset

 is unsatisfiable
\end_layout

\begin_layout Section
inference engines (?)
\end_layout

\begin_layout Subsection
TAUT (tautology checking)
\end_layout

\begin_layout Standard
does the sentencece eval as true
\end_layout

\begin_layout Subsection
SAT (satisfability checking)
\end_layout

\begin_layout Subsection
model checking
\end_layout

\begin_layout Itemize
creates a truth table
\end_layout

\begin_layout Itemize
exponential
\end_layout

\begin_layout Itemize
local search can be applied as first try (incomplete, but sound)
\end_layout

\begin_layout Itemize
translation of sentences in normal form improves time
\end_layout

\begin_layout Subsubsection
conjunctive normal form
\end_layout

\begin_layout Itemize
turn everything in KB into 
\begin_inset Formula $\vee,\wedge$
\end_inset

 of literals
\end_layout

\begin_layout Subsubsection
model search
\end_layout

\begin_layout Itemize
model is a map 
\begin_inset Formula $\{S_{i}\mapsfrom T/F\}$
\end_inset


\end_layout

\begin_layout Paragraph
DPLL
\end_layout

\begin_layout Itemize
early check, check if banal case
\end_layout

\begin_layout Itemize
pure symbol euristics (use only 
\begin_inset Formula $P$
\end_inset

 or 
\begin_inset Formula $\neg P$
\end_inset

)
\end_layout

\begin_layout Itemize
unitary formulae (one literal only)
\end_layout

\begin_layout Subparagraph
def satisfiable(s):
\end_layout

\begin_layout Enumerate
clauses = CNF(s)
\end_layout

\begin_layout Enumerate
symbols = symbols_in(s)
\end_layout

\begin_layout Enumerate
DPLL(clauses, symbols, [])
\end_layout

\begin_layout Subparagraph
def dpll(clauses, symbols, model):
\end_layout

\begin_layout Enumerate
if clauses are true in model: return True
\end_layout

\begin_layout Enumerate
if 
\begin_inset Formula $\exists$
\end_inset

 false clause in model: return False
\end_layout

\begin_layout Enumerate
?????
\end_layout

\begin_layout Paragraph
GSAT
\end_layout

\begin_layout Enumerate
assign true/false randomly
\end_layout

\begin_layout Enumerate
improve assignment, goto 1
\end_layout

\begin_layout Enumerate
if fail, restart randomly
\end_layout

\begin_layout Paragraph
WALKSAT
\end_layout

\begin_layout Enumerate
assign true/false randomly
\end_layout

\begin_layout Enumerate
with probability p flip a random assignment
\end_layout

\begin_layout Enumerate
with probability 1-p flip something good
\end_layout

\begin_layout Section
Deduction
\end_layout

\begin_layout Standard
operate on sentnce with inference
\end_layout

\begin_layout Itemize
input: KB, goal
\end_layout

\begin_layout Itemize
apply inference rules to KB
\end_layout

\begin_layout Itemize
until goal
\end_layout

\begin_layout Subsection
Structures
\end_layout

\begin_layout Itemize
literal: 
\begin_inset Formula $A,\neg B$
\end_inset


\end_layout

\begin_layout Itemize
clauses: (
\begin_inset Formula $\vee$
\end_inset

 f literals)
\end_layout

\begin_layout Itemize
CNF (
\begin_inset Formula $\wedge$
\end_inset

, conjunction of clauses)
\end_layout

\begin_layout Itemize
fluents: 
\begin_inset Formula $A^{0}$
\end_inset

 (literal with time)
\end_layout

\begin_layout Subsubsection
Definite Clause
\end_layout

\begin_layout Standard
clause where only one literal is Positive (C)
\end_layout

\begin_layout Standard
\begin_inset Formula $\neg A\vee\neg B\vee C$
\end_inset


\end_layout

\begin_layout Itemize
they can be turned into 
\begin_inset Formula $(A\vee B)\implies C$
\end_inset


\end_layout

\begin_layout Subsubsection
Horn Clauses
\end_layout

\begin_layout Standard
extends Definite Clause allowing no literal (goal clauses)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\neg A\vee\neg B\vee\neg C$
\end_inset

 horn but not definite clause
\end_layout

\begin_layout Standard
a restricted version of the resolution method
\end_layout

\begin_layout Itemize
proposition symbol
\end_layout

\begin_layout Itemize
(conjunction of symbols ) 
\begin_inset Formula $\implies$
\end_inset

symbol
\end_layout

\begin_layout Subsubsection
CNF
\end_layout

\begin_layout Standard
turn any sentence into a clause (
\begin_inset Formula $\vee$
\end_inset

of literals)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\iff\mapsto\implies\wedge\impliedby$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\implies\mapsto\neg\alpha\vee\beta$
\end_inset

 
\end_layout

\begin_layout Itemize
de morgan to negate literals
\end_layout

\begin_layout Subsection
parsing to CNF
\end_layout

\begin_layout Subsubsection
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 formula types 
\end_layout

\begin_layout Itemize
apply 
\begin_inset Formula $\alpha,\beta$
\end_inset

 rules until you get to CNF
\end_layout

\begin_layout Itemize
???
\end_layout

\begin_layout Itemize
profit
\end_layout

\begin_layout Subsection
Solving with resolution
\end_layout

\begin_layout Enumerate
for every pair 
\begin_inset Formula $C_{1},C_{2}$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\frac{A\cup C_{1}\ \neg A\cup C_{2}}{C_{1}\cup C_{2}}$
\end_inset

, A and 
\begin_inset Formula $\neg A$
\end_inset

 simplify out
\end_layout

\end_deeper
\begin_layout Enumerate
loop until solution
\end_layout

\begin_layout Enumerate
if data goes to
\begin_inset Formula $\emptyset$
\end_inset

: contradiction, no solution
\end_layout

\begin_layout Itemize
proof by contradiction
\end_layout

\begin_layout Itemize
sound
\end_layout

\begin_layout Itemize
complete
\end_layout

\begin_layout Itemize
not validity complete (?) 
\end_layout

\begin_deeper
\begin_layout Itemize
e.g.
 
\begin_inset Formula $\Gamma=\{\{P\}\},C=\{P,Q\}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\Gamma\vdash_{R}C$
\end_inset

, cannot be directly derived with resolution
\end_layout

\end_deeper
\begin_layout Subsubsection
Modus Ponens
\end_layout

\begin_layout Standard
\begin_inset Formula $\frac{\alpha\implies\beta,\alpha}{\beta}$
\end_inset

,
\begin_inset Formula $\frac{precondition}{conclusion}$
\end_inset

, 
\end_layout

\begin_layout Itemize
used to infer
\end_layout

\begin_layout Itemize
when precondition, conclusion
\end_layout

\begin_layout Subsubsection
example run
\end_layout

\begin_layout Enumerate
KB=
\begin_inset Formula $\begin{cases}
\begin{array}{c}
\neg P_{1,1}\\
B_{1,1}\iff(P_{1,2}\vee P_{2,1})\\
B_{2,1}\iff(P_{1,1}\vee P_{2,2}\vee P_{3,1})\\
\neg B_{1,1}\\
B_{2,1}
\end{array}\end{cases}$
\end_inset


\end_layout

\begin_layout Enumerate
biconditional elimination 
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $B_{1,1}\implies(P_{1,2}\vee P_{2,1})\wedge$
\end_inset


\begin_inset Formula $(P_{1,2}\vee P_{2,1})\implies B_{1,1}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
And elimination
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $(P_{1,2}\vee P_{2,1})\implies B_{1,1}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
contraposition
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\neg B_{1,1}\implies\neg(P_{1,2}\vee P_{2,1})$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
modus ponens (infer 
\begin_inset Formula $\beta$
\end_inset

 from 
\begin_inset Formula $(\alpha\implies\beta),\alpha$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\frac{\neg B_{1,1}\implies\neg(P_{1,2}\vee P_{2,1}),\neg B_{1,1}}{\neg(P_{1,2}\vee P_{2,1})}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
de morgan law
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\neg P_{1,2}\wedge\neg P_{2,1}$
\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
monotonic process
\end_layout

\begin_layout Standard
the knowledge never updates, only increases
\end_layout

\begin_layout Subsubsection
Theorems (?)
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Subsubsection
And Elimination
\end_layout

\begin_layout Standard
\begin_inset Formula $\frac{\alpha_{1}\wedge\alpha_{2}\wedge\alpha_{3}\wedge\alpha_{4}}{\alpha_{i}}$
\end_inset


\end_layout

\begin_layout Subsubsection
proof by resolution
\end_layout

\begin_layout Enumerate
KB=
\begin_inset Formula $\begin{cases}
\begin{array}{c}
\neg P_{1,1}\\
B_{1,1}\iff(P_{1,2}\vee P_{2,1})\\
B_{2,1}\iff(P_{1,1}\vee P_{2,2}\vee P_{3,1})\\
\neg B_{1,1}\\
\neg B_{2,1}\\
\neg P_{1,2}\wedge\neg P_{2,1}\\
B_{1,2}\iff(P_{1,1}\vee P_{2,2}\vee P_{1,3})
\end{array}\end{cases}$
\end_inset


\end_layout

\begin_layout Enumerate
similar as before we infer: 
\begin_inset Formula $\neg P_{2,2},\neg P_{1,3}$
\end_inset


\end_layout

\begin_layout Enumerate
also: 
\begin_inset Formula $P_{1,1}\vee P_{2,2}\vee P_{3,1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\neg P_{1,1}$
\end_inset

 resolves with 2) giving, 
\begin_inset Formula $\xcancel{P_{1,1}\vee}P_{2,2}\vee P_{3,1}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\neg P_{2,2}$
\end_inset

 resolves with 2) giving, 
\begin_inset Formula $\xcancel{P_{1,1}\vee P_{2,2}\vee}P_{3,1}$
\end_inset


\end_layout

\begin_layout Subsubsection
resolution
\end_layout

\begin_layout Standard
\begin_inset Formula $\frac{P_{1,1}\vee P_{3,1}\neg P_{1,1}\vee P_{2,2}}{P_{3,1}\vee P_{2,2}}$
\end_inset


\end_layout

\begin_layout Standard
if both S and 
\begin_inset Formula $\neg S$
\end_inset

 appear in a clause (
\begin_inset Formula $\vee$
\end_inset

 of literals) , then we cancel them out
\end_layout

\begin_layout Subsubsection
resolution method
\end_layout

\begin_layout Enumerate
Compile everything KB into clauses 
\end_layout

\begin_layout Enumerate
????
\end_layout

\begin_layout Enumerate
profit
\end_layout

\begin_layout Subsubsection
Forward/Backward chaining
\end_layout

\begin_layout Enumerate
KB is definite clauses.
\end_layout

\begin_layout Enumerate
if all the premises of an implication (A
\begin_inset Formula $\implies$
\end_inset

B) are true
\end_layout

\begin_deeper
\begin_layout Enumerate
add B to the KB
\end_layout

\end_deeper
\begin_layout Paragraph
proof of completness & soundness:
\end_layout

\begin_layout Part
First Order Logic
\end_layout

\begin_layout Section
FoL: Upgrade of Propositional Logic
\end_layout

\begin_layout Standard
adds:
\end_layout

\begin_layout Itemize
objects (robot, wall, tile)
\end_layout

\begin_layout Itemize
relations ( at(robot, tile) )
\end_layout

\begin_layout Subsection
Structures
\end_layout

\begin_layout Itemize
\begin_inset Formula $\neg,\wedge,\vee,\implies,\iff$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\top,\bot$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $=$
\end_inset


\end_layout

\begin_layout Itemize
'(', ')', ','
\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall,\exists,x_{1}$
\end_inset


\end_layout

\begin_layout Subsection
Syntax
\end_layout

\begin_layout Subsubsection
term
\end_layout

\begin_layout Itemize
constants (robot, tile1)
\end_layout

\begin_layout Itemize
variables (x)
\end_layout

\begin_layout Itemize
functional term: f(x,y,g(z,t+3), if f is a function symbol
\end_layout

\begin_layout Subsubsection
atom:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\top,\bot$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $t_{1}=t_{2}$
\end_inset

 where t are terms
\end_layout

\begin_layout Itemize
\begin_inset Formula $P(t_{1}\dots t_{n})$
\end_inset

 P is a predicate symbol
\end_layout

\begin_layout Paragraph
examples
\end_layout

\begin_layout Itemize
Big(homeOf(Giovanni)) : Big 1-ary atom
\end_layout

\begin_layout Itemize
Biger(homeOf(Giovanni), homeOf(Filippo)) : 2-ary atom
\end_layout

\begin_layout Itemize
homeOf(Giovanni)=BatmanCave
\end_layout

\begin_layout Subsubsection
Formula
\end_layout

\begin_layout Itemize
Atoms
\end_layout

\begin_layout Itemize
\begin_inset Formula $\neg Formula$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $A\circ B$
\end_inset

 where 
\begin_inset Formula $\circ$
\end_inset

 is 2-ary
\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall xA,\exists xA$
\end_inset

 x, variable and A Formula
\end_layout

\begin_layout Subsubsection
Eval order
\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall\exists\neg\wedge\vee\implies\iff$
\end_inset


\end_layout

\begin_layout Subsubsection
ground
\end_layout

\begin_layout Standard
ground term/atom do not cointain variable
\end_layout

\begin_layout Subsubsection
bound
\end_layout

\begin_layout Standard
bound x=my_house
\end_layout

\begin_layout Subsubsection
sentence/closed formula
\end_layout

\begin_layout Standard
all variables are bound
\end_layout

\begin_layout Subsection
PL to FoL
\end_layout

\begin_layout Itemize
if 
\begin_inset Formula $\jupiter$
\end_inset

~ KB of PL
\end_layout

\begin_layout Itemize
if
\begin_inset Formula $\jupiter\models A$
\end_inset

, 
\begin_inset Formula $\jupiter$
\end_inset

 is a model of A, or A is true in 
\begin_inset Formula $\jupiter$
\end_inset


\end_layout

\begin_layout Itemize
A: formula 
\begin_inset Formula $A\in L$
\end_inset

 is valid iff it's true in every structure of L (
\begin_inset Formula $\models A)$
\end_inset


\end_layout

\begin_layout Itemize
A: set of formulae 
\begin_inset Formula $\Gamma$
\end_inset

 is satisfiable if there exists a struct 
\begin_inset Formula $\jupiter$
\end_inset

 such that 
\begin_inset Formula $\jupiter\models A$
\end_inset

 for every A in 
\begin_inset Formula $\Gamma$
\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset Formula $\equiv$
\end_inset


\end_layout

\begin_layout Itemize
if the difference is only the variable names
\end_layout

\begin_layout Itemize
if some quantifier does not occur in the formula 
\begin_inset Formula $\forall xP(y)\equiv P(y)$
\end_inset


\end_layout

\begin_layout Paragraph
negation
\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall xP\equiv\neg\exists x\neg P$
\end_inset

, 
\begin_inset Formula $\forall\rightarrow\neg\exists\neg$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\neg\forall xP\equiv\exists x\neg P$
\end_inset

, 
\begin_inset Formula $\neg$
\end_inset

 + above
\end_layout

\begin_layout Itemize
\begin_inset Formula $\exists xP\equiv\neg\forall x\neg P$
\end_inset

, 
\begin_inset Formula $\exists\rightarrow\neg\forall\neg$
\end_inset

, reverse first
\end_layout

\begin_layout Itemize
\begin_inset Formula $\neg\exists xP\equiv\forall x\neg P,$
\end_inset

 
\begin_inset Formula $\neg$
\end_inset

 + above
\end_layout

\begin_layout Paragraph
distribution
\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall$
\end_inset

 over 
\begin_inset Formula $\wedge$
\end_inset

, since 
\begin_inset Formula $\forall$
\end_inset

 is actually 
\begin_inset Formula $\sum$
\end_inset


\begin_inset Formula $x_{i}\and x_{i+1}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\exists$
\end_inset

 over 
\begin_inset Formula $\vee$
\end_inset

, since 
\begin_inset Formula $\exists$
\end_inset

 is actually 
\begin_inset Formula $\sum$
\end_inset


\begin_inset Formula $x_{i}\or x_{i+1}$
\end_inset


\end_layout

\begin_layout Paragraph
implication
\end_layout

\begin_layout Standard
iff x is not free in 
\begin_inset Formula $P_{2}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall xP_{1}\implies P_{2}\equiv\exists x(P_{1}\implies P_{2})$
\end_inset

, 
\begin_inset Formula $\forall$
\end_inset

 over 
\begin_inset Formula $\implies$
\end_inset

, flips
\end_layout

\begin_layout Itemize
\begin_inset Formula $(\exists xP_{1})\implies P_{2}\equiv\forall x(P_{1}\implies P_{2})$
\end_inset

, same for 
\begin_inset Formula $\exists$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $P_{2}\implies\forall xP_{1}\equiv\forall x(P_{2}\implies P_{1})$
\end_inset

, backward, no change
\end_layout

\begin_layout Itemize
same for 
\begin_inset Formula $\exists$
\end_inset


\end_layout

\begin_layout Subsection
Inference
\end_layout

\begin_layout Subsubsection
substitution
\end_layout

\begin_layout Itemize
\begin_inset Formula $\sigma=\{x/t\}$
\end_inset

 or 
\begin_inset Formula $\sigma=\{t=x\}$
\end_inset


\end_layout

\begin_layout Itemize
Subst(
\begin_inset Formula $\sigma,\alpha$
\end_inset

)
\end_layout

\begin_layout Subsubsection
universal instantiation (UI) aka 
\begin_inset Formula $\forall$
\end_inset

 bind
\end_layout

\begin_layout Standard
\begin_inset Formula $\frac{\forall v\,\alpha}{Subst(\{v/g\},\alpha)}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\frac{\forall x\:King(x)\wedge Greedy(x)\implies Evil(x)}{King(Alice)\and Greedy(Alice)\implies Evil(Alice),King(Bob)\and Greedy(Bob)\implies Evil(Bob),...}$
\end_inset


\end_layout

\begin_layout Itemize
x is ANY possible variable, even the ones that don't intuitively fit because
 never declared as King(x)
\end_layout

\begin_layout Subsubsection
Existential instantation (EI) aka 
\begin_inset Formula $\exists$
\end_inset

 bind
\end_layout

\begin_layout Standard
\begin_inset Formula $\frac{\exists v\,\alpha}{Subst(\{v/k\},\alpha)}$
\end_inset


\end_layout

\begin_layout Standard
replace variable with a new unused constant
\end_layout

\begin_layout Subsubsection
effects
\end_layout

\begin_layout Itemize
UI doesn't modify the KB
\end_layout

\begin_layout Itemize
EI modifies KB but doesn't change satisfiability
\end_layout

\begin_layout Subsection
Generalized modus ponent
\end_layout

\begin_layout Standard
\begin_inset Formula $\frac{p_{1},\dots p_{n},(p_{1},\dots p_{n}\implies q)}{Subst(\theta,q)}$
\end_inset


\end_layout

\begin_layout Subsection
Propositionalization (turn FoL into PL)
\end_layout

\begin_layout Itemize
could end up with infinite ground terms (for function symbols)
\end_layout

\begin_deeper
\begin_layout Itemize
some guy proved a finite subset so it's ok
\end_layout

\begin_layout Itemize
only infinite if not entailed
\end_layout

\end_deeper
\begin_layout Itemize
lots of useless facts
\end_layout

\begin_layout Subsubsection
[FoL] CnF
\end_layout

\begin_layout Itemize
remove 
\begin_inset Formula $\implies$
\end_inset


\end_layout

\begin_layout Itemize
move 
\begin_inset Formula $\neg$
\end_inset

 inside
\end_layout

\begin_layout Itemize
rename variables to avoid naming clash
\end_layout

\begin_layout Itemize
remove 
\begin_inset Formula $\exists$
\end_inset

s (turn in prenex form)
\end_layout

\begin_deeper
\begin_layout Itemize
if format
\begin_inset Formula $\exists x\:\alpha$
\end_inset

 (has no 
\begin_inset Formula $\or$
\end_inset

 or 
\begin_inset Formula $\and$
\end_inset

s ) 
\begin_inset Formula $\rightarrow$
\end_inset

 (EI)
\end_layout

\begin_layout Itemize
else: apply skolemization (Skolem normal form)
\end_layout

\begin_deeper
\begin_layout Itemize
s/y/F(x)/
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
drop 
\begin_inset Formula $\forall$
\end_inset


\end_layout

\begin_layout Itemize
distribute 
\begin_inset Formula $\or$
\end_inset

 over 
\begin_inset Formula $\and$
\end_inset


\end_layout

\begin_layout Subsection
Forward chaining
\end_layout

\begin_layout Enumerate
turn 
\begin_inset Formula $\forall/\exists$
\end_inset

 x into 
\begin_inset Formula $X_{i}$
\end_inset


\end_layout

\begin_layout Enumerate
fill 
\begin_inset Formula $\theta$
\end_inset


\end_layout

\begin_layout Enumerate
goto 2
\end_layout

\begin_layout Subsection
Backward chaining
\end_layout

\begin_layout Enumerate
start from goal
\end_layout

\begin_layout Enumerate
fill
\begin_inset Formula $\theta$
\end_inset

 to satisfy unsatisfied terms
\end_layout

\begin_layout Enumerate
go to 2
\end_layout

\begin_layout Subsection
[FoL] resolution
\end_layout

\begin_layout Itemize
rename conflicting variables over different clauses
\end_layout

\begin_layout Itemize
resolve normally
\end_layout

\begin_deeper
\begin_layout Itemize
add to 
\begin_inset Formula $\sigma$
\end_inset

 unifications (skolem funcitons aswell)
\end_layout

\end_deeper
\begin_layout Subsubsection
skolem function
\end_layout

\begin_layout Standard
skolemized and normal are interchangable for refutations (!)
\end_layout

\begin_layout Subsubsection
prenex formula
\end_layout

\begin_layout Itemize
no quantifiers:
\end_layout

\begin_deeper
\begin_layout Itemize
no variables
\end_layout

\begin_layout Itemize
only free variables
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\forall/\exists$
\end_inset

 applied to only one variable
\end_layout

\begin_deeper
\begin_layout Itemize
can be split on 
\begin_inset Formula $\and/\or$
\end_inset

 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\neg\forall/\exists\rightarrow\exists/\forall\neg$
\end_inset

, de morgan law
\end_layout

\end_deeper
\begin_layout Subsection
query KB in FoL
\end_layout

\begin_layout Itemize
query: 
\begin_inset Formula $\exists x\,Person(x)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
true/false
\end_layout

\begin_layout Itemize
\begin_inset Formula $\sigma_{1}=\{x/Alice\}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\sigma_{2}=\{x/Bob\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Part
Situation Calculus (situation ~= state)
\end_layout

\begin_layout Section
Adds
\end_layout

\begin_layout Itemize
action
\end_layout

\begin_layout Itemize
object
\end_layout

\begin_layout Itemize
situation
\end_layout

\begin_layout Subsection
Syntax
\end_layout

\begin_layout Itemize
do(action, situation)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\sqsubseteq/\sqsubset$
\end_inset

 situations operators
\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{i}$
\end_inset

 situations
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $S_{i}=\{\alpha_{0},\alpha_{1}\dots,\alpha_{i-1}\}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{0}=\emptyset$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{i+1}=do(\alpha_{i+1},S_{i})$
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\alpha=put(A,B)$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
fluents
\end_layout

\begin_layout Standard
functions of Situation
\end_layout

\begin_layout Itemize
Relational: True/False
\end_layout

\begin_deeper
\begin_layout Itemize
at, is_empty, etc.
\end_layout

\begin_layout Itemize
\begin_inset Formula $Poss(\alpha,s)$
\end_inset

, true if 
\begin_inset Formula $\alpha$
\end_inset

 is doable in situation s
\end_layout

\end_deeper
\begin_layout Itemize
Functional: Value
\end_layout

\begin_deeper
\begin_layout Itemize
speed(robot, 
\begin_inset Formula $S_{1337}$
\end_inset

)
\end_layout

\end_deeper
\begin_layout Subsection
Actions
\end_layout

\begin_layout Itemize
preconditions
\end_layout

\begin_deeper
\begin_layout Itemize
requirement such that 
\begin_inset Formula $Poss(\alpha,s)=True$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
effects
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $S_{i+1}=do(\alpha,S_{i})$
\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Actions bugs
\end_layout

\begin_layout Subsubsection
Qualification problems
\end_layout

\begin_layout Standard
need to consider every possible term included in S as precondition, this
 explodes in real world
\end_layout

\begin_layout Paragraph
Solution:
\end_layout

\begin_layout Standard
assume specified preconditions are necessary and sufficent.
\end_layout

\begin_layout Subsubsection
Frame problem
\end_layout

\begin_layout Standard
all the effects, S has to be fully updated every action, 2xActionsxFluents,
 but: Persistence some things persist
\end_layout

\begin_layout Paragraph
Solution
\end_layout

\begin_layout Enumerate
1 successor state axiom per fluent
\end_layout

\begin_deeper
\begin_layout Itemize
Adds restrictions but its monotonic
\end_layout

\begin_layout Itemize
split effects of F in : 
\begin_inset Formula $\begin{cases}
\gamma_{F}^{+}(x,\alpha,s) & \implies F(x,do(\alpha,s))\\
\gamma_{F}^{-}(x,\alpha,s) & \implies\neg F(x,do(\alpha,s))
\end{cases}$
\end_inset


\end_layout

\begin_layout Itemize
Unique Name Assumption for actions (UNA)
\end_layout

\begin_layout Itemize
\begin_inset Formula $F(x,do(a,s))\equiv\gamma_{F}^{+}\or F(x,s)\and\gamma_{F}^{-}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $redColor(x,do(\alpha,s))\equiv$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\alpha=paint(red,x)\or redColor(x,s)\and\neg\exists c\:\alpha=paint(c,x)\and c\neq red$
\end_inset


\end_layout

\begin_layout Itemize
is_red if( it happened or (was_red and no_one changed_it))
\end_layout

\end_deeper
\begin_layout Enumerate
Persistence of everything not in effects
\end_layout

\begin_deeper
\begin_layout Itemize
non monotonic
\end_layout

\end_deeper
\begin_layout Subsubsection
Ramification
\end_layout

\begin_layout Standard
some effects are only indirect effect of an action, or, some actions can
 have multiple effects: the intended and indirect ones
\end_layout

\begin_layout Itemize
static axioms (constraint), have no Situation parameter, always active,
 bugs successor state axion
\end_layout

\begin_layout Subsubsection
example
\end_layout

\begin_layout Enumerate
define Fluents, Function(x,y,z,s)
\end_layout

\begin_layout Enumerate
define Actions, function(x,y,z)
\end_layout

\begin_layout Enumerate
define Preconditions(A) for fluents
\end_layout

\begin_layout Enumerate
define successor state axioms((2)A) for fluents
\end_layout

\begin_layout Enumerate
assert UNA (
\begin_inset Formula $\alpha_{1}\neq\alpha_{2}\neq\dots\neq\alpha_{n})$
\end_inset


\end_layout

\begin_layout Enumerate
define initial situation, including that there are no other items, 
\begin_inset Formula $Item(x)\equiv\exists_{i\in[a,f]}i=x$
\end_inset


\end_layout

\begin_layout Subsection
Deductive planning
\end_layout

\begin_layout Itemize
\begin_inset Formula $D\models\exists s\:Goal(s)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $D=\{S_{0},Actions,Prec(Actions),ss(Actions)\}$
\end_inset


\end_layout

\begin_layout Itemize
undecidability
\end_layout

\begin_layout Itemize
non-optimal
\end_layout

\begin_layout Part
Strips
\end_layout

\begin_layout Section
Planning
\end_layout

\begin_layout Itemize
constraint on actions, not list of actions
\end_layout

\begin_layout Subsection
Strips
\end_layout

\begin_layout Itemize
closed world
\end_layout

\begin_layout Itemize
function free (no x)
\end_layout

\begin_layout Subsubsection
Actions
\end_layout

\begin_layout Itemize
precondition: positive lits
\end_layout

\begin_layout Itemize
effects: literals (ADD, DELETE lists)
\end_layout

\begin_layout Itemize
frame problem (assuming peristence)
\end_layout

\begin_layout Itemize
qualification problem (Sitcalc, necess/suff)
\end_layout

\begin_layout Itemize
successor state comes from strips operators
\end_layout

\begin_layout Subsubsection
solution search
\end_layout

\begin_layout Itemize
explore forward the state graph branching on action
\end_layout

\begin_layout Itemize
backward aswell
\end_layout

\begin_layout Subsubsection
heuristic for search
\end_layout

\begin_layout Itemize
relax problem constraints
\end_layout

\begin_layout Itemize
remove preconditions
\end_layout

\begin_layout Itemize
remove negated effects 
\begin_inset Formula $DEL=\emptyset$
\end_inset


\end_layout

\begin_layout Itemize
subgoal indipendence
\end_layout

\begin_layout Subsection
PLANSAT
\end_layout

\begin_layout Standard
is there a goal starting from 
\begin_inset Formula $S_{0}$
\end_inset

?
\end_layout

\begin_layout Subsubsection
Bounded PLANSAT
\end_layout

\begin_layout Standard
within k steps?
\end_layout

\begin_layout Section
Planning graph
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

your heuristics suck
\begin_inset Quotes erd
\end_inset

 -GRAPHPLAN
\end_layout

\begin_layout Subsection
GRAPHPLAN
\end_layout

\begin_layout Standard
algorithm to generate plans from planning graphs
\end_layout

\begin_layout Subsubsection
space description
\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{i}$
\end_inset

 is the set of all the possible (positive literals) that can be true after
 i step
\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{0}$
\end_inset

 initial state, 
\begin_inset Formula $S_{1}$
\end_inset

 all the possible states after 1 action
\end_layout

\begin_layout Itemize
\begin_inset Formula $A_{0}$
\end_inset

 all the possible actions after 
\begin_inset Formula $S_{0}$
\end_inset

, 
\begin_inset Formula $A_{1}$
\end_inset

 all the possible actions after 
\begin_inset Formula $S_{1}$
\end_inset

 (two steps action)
\end_layout

\begin_layout Itemize
mutex are added between actions
\end_layout

\begin_deeper
\begin_layout Itemize
inconsistent effect
\end_layout

\begin_deeper
\begin_layout Itemize
effect vs effect
\end_layout

\end_deeper
\begin_layout Itemize
interference
\end_layout

\begin_deeper
\begin_layout Itemize
effect vs precondition
\end_layout

\end_deeper
\begin_layout Itemize
competing needs
\end_layout

\begin_deeper
\begin_layout Itemize
precondition vs precondition
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
also between literals (states)
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $A,\neg A$
\end_inset


\end_layout

\begin_layout Itemize
if the actions achieving A is mutex with action achieving B
\end_layout

\end_deeper
\begin_layout Subsubsection
Heuristic from planning graph
\end_layout

\begin_layout Itemize
not in final level 
\begin_inset Formula $\implies$
\end_inset

 unreachable
\end_layout

\begin_layout Itemize
cost to 
\begin_inset Formula $goal_{i}\mapsto level\_of\_graph(goal_{i})$
\end_inset


\end_layout

\begin_layout Itemize
cost to Goal
\end_layout

\begin_deeper
\begin_layout Itemize
max-level; max(g1,g2,g3): admissible
\end_layout

\begin_layout Itemize
level sum; sum(g1,g2,g3): not admissible
\end_layout

\begin_layout Itemize
set level; level where (g1,g2,g3) without mutex
\end_layout

\end_deeper
\begin_layout Subsection
Planning with Logic
\end_layout

\begin_layout Enumerate
formalize goal
\end_layout

\begin_layout Enumerate
formalize initial state
\end_layout

\begin_layout Enumerate
formalize transition function (or successor state) as 
\begin_inset Formula $\alpha\and prec(\alpha)\and effect(\alpha)$
\end_inset


\end_layout

\begin_layout Enumerate
extra constraints 
\begin_inset Formula $(\neg\alpha_{1}\or\neg\alpha_{2}\dots)$
\end_inset

 xor actions
\end_layout

\begin_layout Subsection
SAT-PLAN
\end_layout

\begin_layout Enumerate
cnf = translate-to-sat(problem,depth=1)
\end_layout

\begin_layout Enumerate
solve-sat(cnf)
\end_layout

\begin_layout Enumerate
cnf = translate-to-sat(problem,depth=2)
\end_layout

\begin_layout Enumerate
solve-sat(cnf)
\end_layout

\begin_layout Enumerate
...
\end_layout

\begin_layout Enumerate
stop at depth=k
\end_layout

\begin_layout Subsection
CSP planning
\end_layout

\begin_layout Itemize
similar to PL
\end_layout

\begin_layout Section
PoP
\end_layout

\begin_layout Itemize
partial ordering only
\end_layout

\begin_layout Itemize
not full plan
\end_layout

\begin_layout Itemize
u know it
\end_layout

\begin_layout Section
HTN
\end_layout

\begin_layout Standard
decompose plan hierarchically
\end_layout

\begin_layout Subsection
HLA
\end_layout

\begin_layout Standard
high level action
\end_layout

\begin_layout Itemize
has several refinements
\end_layout

\begin_layout Itemize
no preconditions
\end_layout

\begin_layout Itemize
no effects
\end_layout

\begin_layout Subsection
find a plan
\end_layout

\begin_layout Itemize
split in HLAs
\end_layout

\begin_layout Itemize
if HLA has 1 implementation:
\end_layout

\begin_deeper
\begin_layout Itemize
found refinement
\end_layout

\begin_layout Itemize
can define precondition and effect
\end_layout

\end_deeper
\begin_layout Itemize
Recursively explore HLA
\end_layout

\begin_layout Itemize
Reach+/Reach-
\end_layout

\begin_layout Section
Bugs
\end_layout

\begin_layout Itemize
what's the definition of valid formula in PL and FoL?
\end_layout

\begin_layout Itemize
SATplan vs SATx vs SATyca
\end_layout

\end_body
\end_document
