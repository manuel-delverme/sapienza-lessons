<!DOCTYPE html>
<html>
   <button id = "ButtonX">Rotate X</button>
   <button id = "ButtonY">Rotate Y</button>
   <button id = "ButtonZ">Rotate Z</button>
   <button id = "ButtonT">Toggle Rotation</button>
   <button id = "ButtonLightD">LightDir</button>
   <button id = "ButtonLightP">LightPos</button>
   <button id = "ButtonLightS">LightSpot</button>
   <button id = "ButtonShading">Gouraud/Phong</button>

   <!-- 
   <button id = "Shininess_plus">Augmenting Shininess</button>
   <button id = "Shininess_minus">Decreasing Shininess</button>
   <button id = "CF_plus">Augmenting CF</button>
   <button id = "CF_minus">Decreasing CF</button>
   -->

   <script id="vertex-shader" type="x-shader/x-vertex">
      attribute vec4 vPosition;
      attribute vec2 vTexCoord;
      attribute vec4 vNormal;
      attribute vec4 vColor;
      
      varying vec4 fColor;
      varying vec2 fTexCoord;
      
      varying vec3 N;
      
      uniform sampler2D Tex2;
      
      uniform vec4 ambientProduct;
      
      uniform vec4 diffuseProductD;
      uniform vec4 specularProductD;
      
      uniform vec4 diffuseProductP;
      uniform vec4 specularProductP;
      
      uniform vec4 diffuseProductS;
      uniform vec4 specularProductS;
      
      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      
      
      uniform vec3 lightDirectionDir;
      
      uniform vec4 lightPositionPos;
      
      uniform vec4 lightPositionSpot;
      uniform vec3 lightDirectionSpot;
      
      uniform float shininess;
      
      uniform float alpha;
      varying float alpha_Phong;
      
      uniform float C;
      uniform float B;
      uniform float A;
      
      
      uniform float cut_off;
      
      
      uniform bool lightD;
      uniform bool lightP;
      uniform bool lightS;
      uniform bool Gourad;
      
      //Phong adding variables
      
      
      
      varying vec4 ambientProduct_Phong;
      varying float shininess_Phong;
      
      varying vec4 diffuseProductD_Phong;
      varying vec4 specularProductD_Phong;
      
      varying vec4 diffuseProductP_Phong;
      varying vec4 specularProductP_Phong;
      
      varying vec4 diffuseProductS_Phong;
      varying vec4 specularProductS_Phong;
      
      varying float C_Phong;
      varying float B_Phong;
      varying float A_Phong;
      varying float cut_off_Phong;
      
      
      varying vec3 lightDirectionDir_Phong;
      
      varying vec4 lightPositionPos_Phong;
      
      varying vec4 lightPositionSpot_Phong;
      varying vec3 lightDirectionSpot_Phong;
      
      varying vec3 pos_Phong;
      
      
      void main()
      {
      
      	N = normalize((modelViewMatrix*vNormal).xyz);
      	vec3 pos = -(modelViewMatrix * vPosition).xyz;
      
      	if(Gourad){		
      
      		// Compute terms in the illumination equation
      
      		vec4 ambient = ambientProduct;
      		vec3 E = normalize(-pos);
      		/**********************************************/
      			
      		//Directional light
      
      		vec3 light = lightDirectionDir;
      		vec3 L = normalize(light - pos );
      		
      		vec3 H = normalize( L + E);
      
      		float Kd = max( dot(L, N), 0.0 );
      		vec4  diffuseD = Kd*diffuseProductD;
      		float Ks = pow( max(dot(N, H), 0.0), shininess);
      		vec4  specularD = Ks * specularProductD;
      		if( dot(L, N) < 0.0 ) {specularD = vec4(0.0, 0.0, 0.0, 1.0);} 
      
      		
      		//Positional light
      		
      		vec3 light2 = lightPositionPos.xyz;
      		vec3 L2 = light2 - pos;
      		float normLight2 = sqrt((L2.x*L2.x)+(L2.y*L2.y)+(L2.z*L2.z));
      		float attenuation_P = 1.0/(C + B*normLight2 + A*(normLight2*normLight2));
      		L = normalize( L2 );
      		vec3 H2 = normalize( L2 + E);
      		
      
      
      		float Kd2 = max( dot(L2, N), 0.0 );
      		vec4  diffuseP = Kd2*diffuseProductP*attenuation_P;
      	    float Ks2 = pow( max(dot(N, H2), 0.0), shininess );
      	    vec4  specularP = Ks2 * specularProductP*attenuation_P;
      	    if( dot(L2, N) < 0.0 ) {specularP = vec4(0.0, 0.0, 0.0, 1.0);}
      
      		//Spotlight light
      
      		vec3 light3 = lightPositionSpot.xyz;
      		vec3 L3 = light3 - pos;
      
      
      		float normLight3 = sqrt((L3.x*L3.x)+(L3.y*L3.y)+(L3.z*L3.z));
      		float attenuation_S = 1.0/(C + B*normLight3 + A*(normLight3*normLight3));
      
      		L3 = normalize(L3);
      		vec3 H3 = normalize( L3 + E );
      
      		float check_cone = dot(-L3,normalize(lightDirectionSpot));
      
      	    if((check_cone < cut_off)){
      	    	attenuation_S = 0.0;
      	    }
      	    else{
      
      	    	check_cone = pow(check_cone,alpha);
      	    }
      
      
      		float Kd3 = max( dot(L3, N), 0.0 );
      		vec4 diffuseS = Kd3*diffuseProductP*attenuation_S;
      	    float Ks3 = pow( max(dot(N, H3), 0.0), shininess);
      	    vec4 specularS = Ks3 * specularProductS*attenuation_S;
      	    if( dot(L3, N) < 0.0 ) {specularS = vec4(0.0, 0.0, 0.0, 1.0);}
      
      
      		fColor = vColor*(ambient + texture2D(Tex2, fTexCoord));
      
      
      		if(lightD){
      
      			fColor = fColor + vColor*(diffuseD + specularD);
      			
      			}
      		
      		if(lightP) {
      
      			fColor = fColor +  vColor * (diffuseP + specularP);
      			
      			}
      		if(lightS) {
      
      			fColor = fColor + vColor * (diffuseS + specularS)*check_cone;
      		}
      		
      	}
      	else{		
      
      		ambientProduct_Phong   = ambientProduct;
      		shininess_Phong        = shininess;
      
              diffuseProductD_Phong  = diffuseProductD;
              specularProductD_Phong = specularProductD;
              
              diffuseProductP_Phong  = diffuseProductP;
              specularProductP_Phong = specularProductP;
              
      		diffuseProductS_Phong  = diffuseProductS;
      		specularProductS_Phong = specularProductS;
      
      		lightDirectionDir_Phong = lightDirectionDir;
      
      		lightPositionPos_Phong = lightPositionPos;
      
      		lightPositionSpot_Phong = lightPositionSpot;
      
      		lightDirectionSpot_Phong = lightDirectionSpot;
      
      		alpha_Phong = alpha;
      
      		pos_Phong = pos;
      
      		A_Phong = A;
      		B_Phong = B;
      		C_Phong = C;
      
      		cut_off_Phong = cut_off;
      		
      		fColor = vColor;
      	}
      		
      		fColor.a = 1.0;
      		fTexCoord = vTexCoord;
      		gl_Position = projectionMatrix * modelViewMatrix * vPosition;
      }
   </script>
   <script id="fragment-shader" type="x-shader/x-fragment">
      precision mediump float;
      
      varying vec4 fColor;
      varying  vec2 fTexCoord;
      
      
      uniform sampler2D Tex0;
      uniform sampler2D Tex1;
      uniform sampler2D Tex2;
      
      varying float C_Phong;
      varying float B_Phong;
      varying float A_Phong;
      
      varying vec3 N;
      
      varying vec4 ambientProduct_Phong;
      
      varying vec4 diffuseProductD_Phong;
      varying vec4 specularProductD_Phong;
      
      varying float shininess_Phong;
      
      
      varying vec4 diffuseProductP_Phong;
      varying vec4 specularProductP_Phong;
      
      varying vec4 diffuseProductS_Phong;
      varying vec4 specularProductS_Phong;
      
      
      varying vec3 lightDirectionDir_Phong;
      varying vec4 lightPositionPos_Phong;
      varying vec4 lightPositionSpot_Phong;
      varying vec3 lightDirectionSpot_Phong;
      
      varying vec3 pos_Phong;
      
      varying float cut_off_Phong;
      
      varying float alpha_Phong;
      
      
      uniform bool lightP;
      uniform bool lightD;
      uniform bool lightS;
      uniform bool Gourad;
      
      
      void
      main()
      {
      
      	if(Gourad){
      
      		gl_FragColor = fColor * (texture2D(Tex0, fTexCoord)*texture2D(Tex1, fTexCoord));
      	}
      	
      	else{
      
      
      		vec4 lightColors;
      		vec4 ambient = ambientProduct_Phong;
      
      		vec3 pos = pos_Phong;
      
      		vec3 light = lightDirectionDir_Phong.xyz;
      
      		vec3 L = normalize(light - pos);
      		vec3 E = normalize(-pos);
      		vec3 H = normalize( L + E);
      
      
      		//Phong Directional light
      
      		float Kd = max( dot(L, N), 0.0 );
      		vec4 diffuseD = Kd*diffuseProductD_Phong;
      		float Ks = pow( max(dot(N, H), 0.0), shininess_Phong);
      		vec4 specularD = Ks * specularProductD_Phong;
      		if( dot(L, N) < 0.0 ) specularD = vec4(0.0, 0.0, 0.0, 1.0);
      			
      		//Phong Positional Light
      		
      		vec3 light2 = lightPositionPos_Phong.xyz;
      		vec3 L2 = light2 - pos;
      
      		float normLight2 = sqrt((L2.x*L2.x)+(L2.y*L2.y)+(L2.z*L2.z));
      		float attenuation_P = 1.0/(C_Phong + B_Phong * normLight2 + A_Phong * (normLight2*normLight2));
      
      		L = normalize( L2 );
      		vec3 H2 = normalize( L2 + E);
      
      
      		float Kd2 = max( dot(L2, N), 0.0 );
      		vec4  diffuseP = Kd2*diffuseProductP_Phong*attenuation_P;
      	    float Ks2 = pow( max(dot(N, H2), 0.0), shininess_Phong );
      	    vec4  specularP = Ks2 * specularProductP_Phong*attenuation_P;
      	    if( dot(L2, N) < 0.0 ) {specularP = vec4(0.0, 0.0, 0.0, 1.0);}
      	
      	    //Phong Spotlight Light
      
      		vec3 light3 = lightPositionSpot_Phong.xyz;
      		vec3 L3 = light3 - pos;
      		
      
      		float normLight3 = sqrt((L3.x*L3.x)+(L3.y*L3.y)+(L3.z*L3.z));
      		float attenuation_S = 1.0/(C_Phong + B_Phong * normLight3 + A_Phong * (normLight3*normLight3));
      
      		L3 = normalize(L3);
      		vec3 H3 = normalize( L3 + E );
      
      
      		float check_cone = dot(-L3,normalize(lightDirectionSpot_Phong));
      	    if((check_cone < cut_off_Phong)){
      	    	attenuation_S = 0.0;
      	    }
      	    else{
      
      	    	check_cone = pow(check_cone,alpha_Phong);
      	    }
      
      
      	    float Kd3 = max( dot(L3, N),0.0);
      	    float Ks3 = pow( max(dot(N, H3), 0.0), shininess_Phong);
      	    vec4 diffuseS = Kd3*diffuseProductS_Phong*attenuation_S;
      	    vec4 specularS = Ks3 * specularProductS_Phong*attenuation_S;
      
      	    if( dot(L3, N) < 0.0 ) {specularS = vec4(0.0, 0.0, 0.0, 1.0);}
      	    
      
      		lightColors = ambient;
      		
      		if(lightD){
      		
      			lightColors = lightColors + diffuseD + specularD;
      		
      			}
      		
      		if(lightP){
      			
      			lightColors = lightColors + diffuseP + specularP;
      			
      			}
      		
      		if(lightS){
      			
      			lightColors = lightColors + (diffuseS + specularS)*check_cone;
      			
      			}
      
      		gl_FragColor = fColor * (lightColors +texture2D(Tex2, fTexCoord) ) * (texture2D(Tex0, fTexCoord)*texture2D(Tex1, fTexCoord));
      	
      	}
      	
      }
   </script>
   <script type="text/javascript" src="../Common/webgl-utils.js"></script>
   <script type="text/javascript" src="../Common/initShaders.js"></script>
   <script type="text/javascript" src="../Common/MV.js"></script>
   <script type="text/javascript" src="Homework_DELVERME.js"></script>
   <body>
      <canvas id="gl-canvas" width="1024" height="1024">
         Oops ... your browser doesn't support the HTML5 canvas element
      </canvas>
   </body>
</html>
